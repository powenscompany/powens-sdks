/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package com.powens.client

import com.powens.api.model.AdditionalProperties
import com.powens.api.model.Connection
import com.powens.api.model.ConnectionRequest
import com.powens.api.model.ConnectionUpdateRequest
import com.powens.api.model.ConnectionsList
import com.powens.api.model.Error

import org.openapitools.client.infrastructure.*
import io.ktor.client.HttpClientConfig
import io.ktor.client.request.forms.formData
import io.ktor.client.engine.HttpClientEngine
import kotlinx.serialization.json.Json
import io.ktor.http.ParametersBuilder
import kotlinx.serialization.*
import kotlinx.serialization.descriptors.*
import kotlinx.serialization.encoding.*

open class ConnectionsApi(
    baseUrl: String = ApiClient.BASE_URL,
    httpClientEngine: HttpClientEngine? = null,
    httpClientConfig: ((HttpClientConfig<*>) -> Unit)? = null,
    jsonSerializer: Json = ApiClient.JSON_DEFAULT
) : ApiClient(baseUrl, httpClientEngine, httpClientConfig, jsonSerializer) {

    /**
     * Add a connection
     * Create a new connection for the authenticated user, for &#x60;credentials&#x60; connectors. The request implies a synchronous interaction with the connector website or API to perform the initial credentials check, so client-side timeouts must be configured to allow a reponse time up to a few minutes. 
     * @param requestBody 
     * @param expand  (optional)
     * @param source  (optional)
     * @return Connection
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun createUserConnection(requestBody: AdditionalProperties<kotlin.String, kotlin.String>, expand: kotlin.collections.List<kotlin.String>? = null, source: kotlin.String? = null): HttpResponse<Connection> {

        val localVariableAuthNames = listOf<String>("bi_auth")

        val localVariableBody = CreateUserConnectionRequest(requestBody)

        val localVariableQuery = mutableMapOf<String, List<String>>()
        expand?.apply { localVariableQuery["expand"] = toMultiValue(this, "csv") }
        source?.apply { localVariableQuery["source"] = listOf("$source") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/users/me/connections",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }

    @Serializable
    private class CreateUserConnectionRequest(val value: Map<kotlin.String, kotlin.String>) {
        @Serializer(CreateUserConnectionRequest::class)
        companion object : KSerializer<CreateUserConnectionRequest> {
            private val serializer: KSerializer<Map<kotlin.String, kotlin.String>> = serializer<Map<String, kotlin.String>>()
            override val descriptor = serializer.descriptor
            override fun serialize(encoder: Encoder, obj: CreateUserConnectionRequest) = serializer.serialize(encoder, obj.value)
            override fun deserialize(decoder: Decoder) = CreateUserConnectionRequest(serializer.deserialize(decoder))
        }
    }

    /**
     * Delete a connection
     * Delete a user connection. All associated data is permanently made unavailable in the API.
     * @param connectionId Connection ID.
     * @param expand  (optional)
     * @return void
     */
    open suspend fun deleteUserConnection(connectionId: kotlin.Long, expand: kotlin.collections.List<kotlin.String>? = null): HttpResponse<Unit> {

        val localVariableAuthNames = listOf<String>("bi_auth")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        expand?.apply { localVariableQuery["expand"] = toMultiValue(this, "csv") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.DELETE,
            "/users/me/connections/{connectionId}".replace("{" + "connectionId" + "}", "$connectionId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Connection
     * Get a single connection of the authenticated user by ID.
     * @param connectionId Connection ID.
     * @param expand  (optional)
     * @return Connection
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getUserConnection(connectionId: kotlin.Long, expand: kotlin.collections.List<kotlin.String>? = null): HttpResponse<Connection> {

        val localVariableAuthNames = listOf<String>("bi_auth")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        expand?.apply { localVariableQuery["expand"] = toMultiValue(this, "csv") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/users/me/connections/{connectionId}".replace("{" + "connectionId" + "}", "$connectionId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * List connections
     * List all connections of the authenticated user.
     * @param expand  (optional)
     * @return ConnectionsList
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun listUserConnections(expand: kotlin.collections.List<kotlin.String>? = null): HttpResponse<ConnectionsList> {

        val localVariableAuthNames = listOf<String>("bi_auth")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        expand?.apply { localVariableQuery["expand"] = toMultiValue(this, "csv") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/users/me/connections",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Open the connector webview
     * A special redirection endpoint for &#x60;webauth&#x60; connections. The URL must be opened in a browser.
     * @param clientId The client ID of your client application.
     * @param token A temporary authorization code to secure the call.
     * @param redirectUri The final redirect URL to be redirected to after the flow has completed. This URL must not contain query parameters. Be sure to properly encode it.
     * @param idConnector To add a new connection only, the ID of the connector. The connector must have webauth as its auth_mechanism. (optional)
     * @param idConnection To recover or resume a connection only, the ID of the connection. (optional)
     * @param source  (optional)
     * @param state An optional opaque string that will be returned &#39;as is&#39; with the redirect URL. (optional)
     * @return void
     */
    open suspend fun openWebauth(clientId: kotlin.Long, token: kotlin.String, redirectUri: kotlin.String, idConnector: kotlin.Long? = null, idConnection: kotlin.Long? = null, source: kotlin.String? = null, state: kotlin.String? = null): HttpResponse<Unit> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        clientId?.apply { localVariableQuery["client_id"] = listOf("$clientId") }
        token?.apply { localVariableQuery["token"] = listOf("$token") }
        redirectUri?.apply { localVariableQuery["redirect_uri"] = listOf("$redirectUri") }
        idConnector?.apply { localVariableQuery["id_connector"] = listOf("$idConnector") }
        idConnection?.apply { localVariableQuery["id_connection"] = listOf("$idConnection") }
        source?.apply { localVariableQuery["source"] = listOf("$source") }
        state?.apply { localVariableQuery["state"] = listOf("$state") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/webauth",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Update and/or sync a connection
     * Update the configuration or the credentials of a connection, and/or perform a sync afterward.
     * @param connectionId Connection ID.
     * @param expand  (optional)
     * @param source  (optional)
     * @param background Flag to make the request asynchronous (i.e. the API will respond immediately and process the action in background). When using this option, you must implement polling on the resource to monitor the state. (optional)
     * @param requestBody The request can optionally include new credentials or values to update the connection. An empty request performs a sync. (optional)
     * @return Connection
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun updateSyncUserConnection(connectionId: kotlin.Long, expand: kotlin.collections.List<kotlin.String>? = null, source: kotlin.String? = null, background: kotlin.Boolean? = null, requestBody: AdditionalProperties<kotlin.String, kotlin.String>? = null): HttpResponse<Connection> {

        val localVariableAuthNames = listOf<String>("bi_auth")

        val localVariableBody = UpdateSyncUserConnectionRequest(requestBody ?: emptyMap())

        val localVariableQuery = mutableMapOf<String, List<String>>()
        expand?.apply { localVariableQuery["expand"] = toMultiValue(this, "csv") }
        source?.apply { localVariableQuery["source"] = listOf("$source") }
        background?.apply { localVariableQuery["background"] = listOf("$background") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/users/me/connections/{connectionId}".replace("{" + "connectionId" + "}", "$connectionId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }

    @Serializable
    private class UpdateSyncUserConnectionRequest(val value: Map<kotlin.String, kotlin.String>) {
        @Serializer(UpdateSyncUserConnectionRequest::class)
        companion object : KSerializer<UpdateSyncUserConnectionRequest> {
            private val serializer: KSerializer<Map<kotlin.String, kotlin.String>> = serializer<Map<String, kotlin.String>>()
            override val descriptor = serializer.descriptor
            override fun serialize(encoder: Encoder, obj: UpdateSyncUserConnectionRequest) = serializer.serialize(encoder, obj.value)
            override fun deserialize(decoder: Decoder) = UpdateSyncUserConnectionRequest(serializer.deserialize(decoder))
        }
    }

}
