/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package com.powens.api.client.services

import com.powens.api.model.Connection
import com.powens.api.model.ConnectionRequest
import com.powens.api.model.ConnectionUpdateRequest
import com.powens.api.model.ConnectionsList
import com.powens.api.model.ServiceError

import com.powens.api.infrastructure.*
import io.ktor.client.HttpClient
import io.ktor.client.HttpClientConfig
import io.ktor.client.request.forms.formData
import io.ktor.client.engine.HttpClientEngine
import kotlinx.serialization.json.Json
import io.ktor.http.ParametersBuilder
import kotlinx.serialization.*
import kotlinx.serialization.descriptors.*
import kotlinx.serialization.encoding.*

open class ConnectionsApi : ApiClient {

    constructor(
        baseUrl: String = ApiClient.BASE_URL,
        httpClientEngine: HttpClientEngine? = null,
        httpClientConfig: ((HttpClientConfig<*>) -> Unit)? = null,
        jsonSerializer: Json = ApiClient.JSON_DEFAULT
    ) : super(baseUrl = baseUrl, httpClientEngine = httpClientEngine, httpClientConfig = httpClientConfig, jsonBlock = jsonSerializer)

    constructor(
        baseUrl: String,
        httpClient: HttpClient
    ): super(baseUrl = baseUrl, httpClient = httpClient)


    /**
     * enum for parameter expand
     */
    @Serializable
    enum class ExpandCreateUserConnection(val value: kotlin.String) {
        
        @SerialName(value = "connector")
        Connector("connector"),
        
        @SerialName(value = "sources")
        Sources("sources"),
        
        @SerialName(value = "accounts")
        Accounts("accounts"),
        
        @SerialName(value = "all_accounts")
        AllAccounts("all_accounts")
        
    }

    /**
     * Add a connection
     * Create a new connection for the authenticated user, for &#x60;credentials&#x60; connectors. The request implies a synchronous interaction with the connector website or API to perform the initial credentials check, so client-side timeouts must be configured to allow a response time up to a few minutes. 
     * @param connectionRequest 
     * @param source  (optional)
     * @param expand  (optional)
     * @return Connection
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun createUserConnection(connectionRequest: ConnectionRequest, source: kotlin.String? = null, expand: kotlin.collections.List<ExpandCreateUserConnection>? = null): HttpResponse<Connection> {

        val localVariableAuthNames = listOf<String>("bi_auth")

        val localVariableBody = connectionRequest

        val localVariableQuery = mutableMapOf<String, List<String>>()
        source?.apply { localVariableQuery["source"] = listOf("$source") }
        expand?.apply { localVariableQuery["expand"] = toMultiValue(this, "csv") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/users/me/connections",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Delete a connection
     * Delete a user connection. All associated data is permanently made unavailable in the API.
     * @param connectionId Connection ID.
     * @return void
     */
    open suspend fun deleteUserConnection(connectionId: kotlin.Long): HttpResponse<Unit> {

        val localVariableAuthNames = listOf<String>("bi_auth")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.DELETE,
            "/users/me/connections/{connectionId}".replace("{" + "connectionId" + "}", "$connectionId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * enum for parameter expand
     */
    @Serializable
    enum class ExpandGetUserConnection(val value: kotlin.String) {
        
        @SerialName(value = "connector")
        Connector("connector"),
        
        @SerialName(value = "sources")
        Sources("sources"),
        
        @SerialName(value = "accounts")
        Accounts("accounts"),
        
        @SerialName(value = "all_accounts")
        AllAccounts("all_accounts")
        
    }

    /**
     * Connection
     * Get a single connection of the authenticated user by ID.
     * @param connectionId Connection ID.
     * @param expand  (optional)
     * @return Connection
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getUserConnection(connectionId: kotlin.Long, expand: kotlin.collections.List<ExpandGetUserConnection>? = null): HttpResponse<Connection> {

        val localVariableAuthNames = listOf<String>("bi_auth")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        expand?.apply { localVariableQuery["expand"] = toMultiValue(this, "csv") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/users/me/connections/{connectionId}".replace("{" + "connectionId" + "}", "$connectionId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * enum for parameter expand
     */
    @Serializable
    enum class ExpandListUserConnections(val value: kotlin.String) {
        
        @SerialName(value = "connector")
        Connector("connector"),
        
        @SerialName(value = "sources")
        Sources("sources"),
        
        @SerialName(value = "accounts")
        Accounts("accounts"),
        
        @SerialName(value = "all_accounts")
        AllAccounts("all_accounts")
        
    }

    /**
     * List connections
     * List all connections of the authenticated user.
     * @param expand  (optional)
     * @return ConnectionsList
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun listUserConnections(expand: kotlin.collections.List<ExpandListUserConnections>? = null): HttpResponse<ConnectionsList> {

        val localVariableAuthNames = listOf<String>("bi_auth")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        expand?.apply { localVariableQuery["expand"] = toMultiValue(this, "csv") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/users/me/connections",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Open the connector webview
     * A special redirection endpoint for &#x60;webauth&#x60; connections. The URL must be opened in a browser.
     * @param clientId The client ID of your client application.
     * @param token A temporary authorization code to secure the call.
     * @param redirectUri The final redirect URL to be redirected to after the flow has completed. This URL must not contain query parameters. Be sure to properly encode it.
     * @param idConnector To add a new connection only, the ID of the connector. The connector must have &#x60;webauth&#x60; as its &#x60;auth_mechanism&#x60;. (optional)
     * @param idConnection To recover or resume a connection only, the ID of the connection. (optional)
     * @param source  (optional)
     * @param state An optional opaque string that will be returned &#39;as is&#39; with the redirect URL. (optional)
     * @return void
     */
    open suspend fun openWebAuth(clientId: kotlin.Long, token: kotlin.String, redirectUri: kotlin.String, idConnector: kotlin.Long? = null, idConnection: kotlin.Long? = null, source: kotlin.String? = null, state: kotlin.String? = null): HttpResponse<Unit> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        clientId?.apply { localVariableQuery["client_id"] = listOf("$clientId") }
        token?.apply { localVariableQuery["token"] = listOf("$token") }
        redirectUri?.apply { localVariableQuery["redirect_uri"] = listOf("$redirectUri") }
        idConnector?.apply { localVariableQuery["id_connector"] = listOf("$idConnector") }
        idConnection?.apply { localVariableQuery["id_connection"] = listOf("$idConnection") }
        source?.apply { localVariableQuery["source"] = listOf("$source") }
        state?.apply { localVariableQuery["state"] = listOf("$state") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/webauth",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * enum for parameter expand
     */
    @Serializable
    enum class ExpandUpdateSyncUserConnection(val value: kotlin.String) {
        
        @SerialName(value = "connector")
        Connector("connector"),
        
        @SerialName(value = "sources")
        Sources("sources"),
        
        @SerialName(value = "accounts")
        Accounts("accounts"),
        
        @SerialName(value = "all_accounts")
        AllAccounts("all_accounts")
        
    }

    /**
     * Update and/or sync a connection
     * Update the configuration or the credentials of a connection, and/or perform a sync afterward.
     * @param connectionId Connection ID.
     * @param source  (optional)
     * @param background Flag to make the request asynchronous (i.e. the API will respond immediately and process the action in background). When using this option, you must implement polling on the resource to monitor the state. (optional)
     * @param expand  (optional)
     * @param connectionUpdateRequest The request can optionally include new credentials or values to update the connection. An empty request performs a sync. (optional)
     * @return Connection
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun updateSyncUserConnection(connectionId: kotlin.Long, source: kotlin.String? = null, background: kotlin.Boolean? = null, expand: kotlin.collections.List<ExpandUpdateSyncUserConnection>? = null, connectionUpdateRequest: ConnectionUpdateRequest? = null): HttpResponse<Connection> {

        val localVariableAuthNames = listOf<String>("bi_auth")

        val localVariableBody = connectionUpdateRequest

        val localVariableQuery = mutableMapOf<String, List<String>>()
        source?.apply { localVariableQuery["source"] = listOf("$source") }
        background?.apply { localVariableQuery["background"] = listOf("$background") }
        expand?.apply { localVariableQuery["expand"] = toMultiValue(this, "csv") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/users/me/connections/{connectionId}".replace("{" + "connectionId" + "}", "$connectionId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



}
